try:
    from Tkinter import messagebox
except ImportError:
    from tkinter import messagebox

import os
import struct

from models import Namespace, Issue

try:
    import psutil
except ImportError:
    global psutil
    psutil = None

class Storage:

    LOCKFILE = "session.lock"
    
    def __init__(self, basedir, reg_exit=None):
        self.__base = basedir
        if not os.path.isdir(basedir):
            os.mkdir(basedir)
            self.__ns = []
            self.__data = {}
            self.__create_lockfile(reg_exit)
        else:
            if os.path.exists(os.path.join(basedir, 'namespaces.txt')):
                # check for lockfile
                self.__create_lockfile(reg_exit)
                
                # TODO - be able to gracefully handle individual corrupted files?
                success = self.__load()
                if not success:
                    print("WARNING: Corrupted program data. Using a blank workspace.")
                    self.__ns = []
                    self.__data = {}
            else:
                self.__ns = []
                self.__data = {}

    def __create_lockfile(self, reg_exit):
        if psutil is None:
            messagebox.showinfo("Notice", "The dependencies to protect against corruption via running multiple instances of this program are not present. Be sure not to have multiple instances of this program open at once.")
            return
        
        lockfile = os.path.join(self.__base, Storage.LOCKFILE)
        if os.path.exists(lockfile):
            # check if written PID refers to a living python process
            f = open(lockfile, 'r')
            _pid = f.read()
            f.close()

            override = True
            try:
                pid = int(_pid)
                try:
                    proc = psutil.Process(pid)
                    if proc.name() == "python" or proc.name() == "python3":
                        override = False
                except psutil.NoSuchProcess:
                    pass
            except ValueError:
                pass # invalid PID? lockfile wasn't generated by this.

            if override:
                f = open(lockfile, 'w')
                f.write(str(os.getpid()))
                f.close()
            else:
                raise LockfileError("To-do data is locked, make sure no other instance is running!")
            
        else:
            f = open(lockfile, 'w')
            f.write(str(os.getpid()))
            f.close()

        if reg_exit is not None:    
            reg_exit(self.__dereg)

    def __dereg(self):
        os.remove(os.path.join(self.__base, Storage.LOCKFILE))

    @property
    def namespaces(self):
        return list(self.__ns)

    def addNamespace(self, ns):
        assert isinstance(ns, Namespace)
        self.__ns.append(ns)
        self.__data[ns.key] = []

        self.save()

    def getNamespaceByKey(self, key):
        for i in self.__ns:
            if i.key == key:
                return i
        return None

    def namespaceExists(self, ns):
        for space in self.__ns:
            if ns.url == space.url and ns.user == space.user and ns.repo == space.repo:
                return True
        return False

    def addIssue(self, nskey, iss):
        # TODO - assert that nskey represents a valid namespace?
        self.__data[nskey].append(iss)
        self.save()

    def getIssueById(self, nskey, issId):
        for iss in self.__data[nskey]:
            if iss.id == issId:
                return iss
        return None

    def removeIssue(self, nskey, idx):
        del self.__data[nskey][idx]
        self.save()

    def getIssues(self, nskey):
        return list(self.__data[nskey])

    def __load(self):
        try:
            handle = open(os.path.join(self.__base, "namespaces.txt"), mode='r', encoding='utf-8')
            content = handle.read()
            handle.close()

            self.__ns = []
            self.__data = {}
            namespaces = content.split("\n")
            for namespace in namespaces:
                ns = Namespace.fromstr(namespace)
                if ns is not None:
                    self.__ns.append(ns)
                    self.__data[ns.key] = []

            for namespace in self.__ns:
                key = namespace.key
                handle = open(os.path.join(self.__base, key), 'rb')
                entries = struct.unpack('>h', handle.read(2))[0]
                issues = []
                for entry in range(0, entries):
                    issue_no = struct.unpack('>h', handle.read(2))[0]
                    desc_len = struct.unpack('>h', handle.read(2))[0]
                    desc = handle.read(desc_len).decode('utf-8')
                    issues.append(Issue(issue_no, desc))
                self.__data[key] = issues

            return True
        except Exception as e:
            print(e)
            return False

    def save(self):
        nslines = []
        for ns in self.__ns:
            nslines.append(str(ns))
            entries = self.__data[ns.key]
            handle = open(os.path.join(self.__base, ns.key), 'wb')
            handle.write(struct.pack('>h', len(entries)))
            for entry in entries:
                handle.write(struct.pack('>h', entry.id))
                desc = entry.description.encode()
                handle.write(struct.pack('>h', len(desc)))
                handle.write(desc)
            handle.close()

        nsdata = '\n'.join(nslines)
        handle = open(os.path.join(self.__base, 'namespaces.txt'), 'w')
        handle.write(nsdata)
        handle.close()
